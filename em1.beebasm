; For now I'm targetting a Master 128 and will use CMOS instructions freely.
    cpu 1

romsel = &fe30
romsel_copy = &f4

osasci = &ffe3

; TODO: Rename to "clear_bits"?
macro and_not n
    and #not(n) and &ff
endmacro

; TODO: I'm putting paging in a macro partly in case there's a way I can disable interrupts most of the time and then get away with not having to update romsel_copy
macro page_in_bank_a
    sta romsel_copy
    sta romsel
endmacro
macro page_in_bank_y
    sty romsel_copy
    sty romsel
endmacro

; TODO: This macro may not be all that useful if we only call it once, but let's go with it for now
macro set_z80_pc_abs abs
    ldx #hi(abs)
    stx z80_pch_logical
    lda swr_bank_table,x
    page_in_bank_a
    lda #(hi(abs) and %00111111) or %10000000
    sta z80_pch_physical
    ldy #lo(abs)
endmacro
    
; The main instruction dispatch loop is executed from zero page.
; The handlers may use A and X as scratch registers but must return with:
; - Y holding the low byte of the Z80 PC
; - the RAM bank containing the Z80 PC paged in
    org 0
    guard &90
.zp_code_start
.dispatch_loop
{
    iny
    beq new_pc_page
.new_pc_page_return
.^dispatch_loop_no_increment
.^lda_z80_pc_physical_abs_y
    lda &ff00,y
; TODO: START TEMP HACK TO DETECT EXECUTING AT $0005
    sta zp_tmp
    cpy #5
    bne not_5
    lda z80_pch_logical
    bne not_5
    jmp bdos_emulation
.not_5
    lda zp_tmp
; TODO: END TEMP HACK
    asl a
    tax
    bcs top_bit_set_opcode
    jmp (dispatch_table_low,x)
.top_bit_set_opcode
    jmp (dispatch_table_high,x)

.new_pc_page
    ; TODO: This could potentially be put into a subroutine without too much
    ; performance impact if we're short on zero page space.
    inc z80_pch_logical
    inc z80_pch_physical
    lda z80_pch_physical
    cmp #&c0
    bne new_pc_page_return
    ; TODO: Might be more efficient to jmp to some variant on update_z80_pch_physical which finishes by doing jmp dispatch_loop_no_increment
    jsr update_z80_pch_physical
    jmp new_pc_page_return
}
.zp_code_end
zp_code_len = zp_code_end - zp_code_start

; Zero page variables
.z80_pch_logical equb 0
z80_pc_physical = lda_z80_pc_physical_abs_y + 1
z80_pch_physical = lda_z80_pc_physical_abs_y + 2
.z80_pc_physical_bank_tmp equb 0 ; normally paged in, just temporary storage
.z80_pcl_tmp equb 0 ; normally in Y, just temporary storage
.z80_a equb 0
.z80_f equb 0
.z80_b equb 0
.z80_c equb 0
.z80_d equb 0
.z80_e equb 0
.z80_h equb 0
.z80_l equb 0
.z80_sp equw 0
.z80_ix equw 0
.z80_iy equw 0
.operand_ptr equw 0 ; low byte always 0
.zp_tmp equw 0 ; temporary workspace

; The 6502 N, Z and C flags correspond closely to the Z80 S, Z and C flags,
; although they live at different bit positions in the flags register. To track
; the Z80 flags as efficiently as possible, z80_f holds "hybrid flags" - these
; are the Z80 flags but rearranged to use the 6502 bit positions. These need to
; be converted to use the correct bit positions when exposed to code running on
; the emulated Z80. SFTODO: I AM ALSO TRYING TO "SHARE" THE V FLAG NOW
;
;        b76543210
; Hybrid: SP H NZC
; Z80:    SZ H PNC
hybrid_flag_s = 1 << 7 ; 6502 N flag
hybrid_flag_p = 1 << 6 ; 6502 V flag (Z80 P and Z80 V are same flag bit)
hybrid_flag_h = 1 << 4
hybrid_flag_n = 1 << 2
hybrid_flag_z = 1 << 1 ; 6502 Z flag
hybrid_flag_c = 1 << 0 ; 6502 C flag
hybrid_flag_sz = hybrid_flag_s or hybrid_flag_z
hybrid_flag_szpc = hybrid_flag_s or hybrid_flag_z or hybrid_flag_p or hybrid_flag_c
hybrid_flag_zh = hybrid_flag_z or hybrid_flag_h
hybrid_flag_zhn = hybrid_flag_z or hybrid_flag_h or hybrid_flag_n
hybrid_flag_hnc = hybrid_flag_h or hybrid_flag_n or hybrid_flag_c
hybrid_flag_hpn = hybrid_flag_h or hybrid_flag_p or hybrid_flag_n

    org &e00
    guard &8000
.start
    ; Copy the zero page code into the correct location.
{
    assert zp_code_len <= 128
    ldy #zp_code_len - 1
.loop
    lda zp_code_copy,y
    sta zp_code_start,y
    dey
    bpl loop
}

    ; Initialise zero page.
    lda #0
    sta operand_ptr
    ; TODO: Initialise other stuff too?

    ; Store top of RAM at address 6. TODO: This is a bit of a hack but it seems
    ; to be what zexall wants to initialise sp; I suspect eventually this will
    ; be populated by the CP/M BDOS or whatever.
    lda #4
    page_in_bank_a
    lda #0
    sta &8006
    lda #&f0
    sta &8007

    ; TODO: This isn't the right start address, but during initial development I
    ; will just have a validation program pre-loaded into memory here.
    set_z80_pc_abs &100

    ; Start executing instructions.
    jmp dispatch_loop_no_increment


; Update z80_pch_physical and page in the correct RAM bank to match z80_pch_logical.
.update_z80_pch_physical
    ldx z80_pch_logical
    lda swr_bank_table,x
    page_in_bank_a
    txa
    and #%00111111
    ora #%10000000
    sta z80_pch_physical
    rts

.update_z80_pch_physical_and_dispatch
; TODO: DUPLICATION OF CODE FOR PREV VERSION, SHARE VIA MACRO
    ldx z80_pch_logical
    lda swr_bank_table,x
    page_in_bank_a
    txa
    and #%00111111
    ora #%10000000
    sta z80_pch_physical
    jmp dispatch_loop_no_increment

    ; TODO: Get rid of this when all opcodes implemented
.opcode_todo
    brk

    ; TODO MOVE MACROS TO TOP
macro advance_pc_and_load
    iny
    ; TODO: Can I avoid having to take the branch in the common case?
    bne not_new_pc_page
    ; TODO: Copy of code in zp dispatch loop, factor out using a macro?
    inc z80_pch_logical
    inc z80_pch_physical
    ; TODO: Can we do "bit z80_pch_physical:bvc not_new_pc_bank" here, to save the cmp?
    lda z80_pch_physical
    cmp #&c0
    bne not_new_pc_bank
    jsr update_z80_pch_physical
.not_new_pc_page
.not_new_pc_bank
    lda (z80_pc_physical),y
endmacro

    ; TODO: Copy of code in zp dispatch loop, factor out using a macro?
.new_pc_page_and_dispatch_loop_no_increment
{
    inc z80_pch_logical
    inc z80_pch_physical
    ; TODO: bit:bvc optimisation as in advance_pc_and_load?
    lda z80_pch_physical
    cmp #&c0
    bne not_new_pc_bank
    jsr update_z80_pch_physical
.not_new_pc_bank
    jmp dispatch_loop_no_increment
}

; TODO: DESCRIBE
; TODO: MAKE A MACRO?
.set_operand_ptr_using_a
    tax
    and #%00111111
    ora #%10000000
    sta operand_ptr + 1
    lda swr_bank_table,x
    page_in_bank_a
    rts

; Increment Y and/or operand_ptr so lda (operand_ptr),y accesses the next byte.
; TODO: MAKE A MACRO?
.bump_operand_ptr_y
{
    iny
    beq new_page
    rts
.new_page
    inc operand_ptr + 1
    ; TODO: bit:bvc test as in advance_pc_and_load?
    lda operand_ptr + 1
    cmp #&c0
    beq new_bank
    rts
.new_bank
    lda #&80
    sta operand_ptr + 1
    ; TODO: This is a hack - it relies on the banks being contiguous on Master.
    lda romsel_copy
    inc a
    page_in_bank_a
    rts
}

; TODO: Maybe fold storing/restoring Y into these macros as well? Change name of course.
macro store_pc_bank_and_y
    sty z80_pcl_tmp
    ldy romsel_copy
    sty z80_pc_physical_bank_tmp
endmacro

; This preserves A and X.
macro restore_pc_bank_and_y
    ldy z80_pc_physical_bank_tmp
    page_in_bank_y
    ldy z80_pcl_tmp
endmacro

; TODO: This may be useful in places which currently have this code written out inline
macro set_operand_ptr_using_imm_16
    advance_pc_and_load
    sta zp_tmp
    advance_pc_and_load
    store_pc_bank_and_y
    jsr set_operand_ptr_using_a
    ldy zp_tmp
endmacro

macro ld_r_8 r
    advance_pc_and_load
    sta r
    jmp dispatch_loop
endmacro

; TODO: MOVE MACRO TO TOP
macro ld_r_s_fragment r, s
    lda s
    sta r
endmacro

macro ld_r_s r, s
    ld_r_s_fragment r, s
    jmp dispatch_loop
endmacro

macro ld_rr_16 high_r, low_r
    advance_pc_and_load
    sta low_r
    advance_pc_and_load
    sta high_r
    jmp dispatch_loop
endmacro

macro lda_ind_rr high_r, low_r
    store_pc_bank_and_y
    lda high_r
    jsr set_operand_ptr_using_a
    ldy low_r
    lda (operand_ptr),y
    restore_pc_bank_and_y
endmacro

; TODO: Careful not to use this if there are cases where we could avoid the zp_tmp use - in some cases we can't, but there may be some where we can
; TODO: If all uses of this macro then do jmp dispatch_loop can rewrite this as sta zp_tmp:ld_ind_hl_r zp_tmp
macro sta_ind_hl_via_tmp_fragment
    sta zp_tmp
    store_pc_bank_and_y
    lda z80_h
    jsr set_operand_ptr_using_a
    ldy z80_l
    lda zp_tmp
    sta (operand_ptr),y
    restore_pc_bank_and_y
endmacro

macro ld_ind_rr_r high_r, low_r, s
    store_pc_bank_and_y
    lda high_r
    jsr set_operand_ptr_using_a
    ldy low_r
    lda s
    sta (operand_ptr),y
    restore_pc_bank_and_y
    jmp dispatch_loop
endmacro

macro ld_ind_hl_r r
    ld_ind_rr_r z80_h, z80_l, r
endmacro

macro ld_rr_ind_abs high_r, low_r
    set_operand_ptr_using_imm_16
    lda (operand_ptr),y
    sta low_r
    jsr bump_operand_ptr_y
    lda (operand_ptr),y
    sta high_r
    restore_pc_bank_and_y
    jmp dispatch_loop
endmacro

macro ld_r_ind_rr r, high_s, low_s
    ; Note that r can be the same as one of high_s or low_s; this doesn't cause any special complications though.
    lda_ind_rr high_s, low_s
    sta r
    jmp dispatch_loop
endmacro

macro lda_ind_hl
    lda_ind_rr z80_h, z80_l
endmacro

macro ld_r_ind_hl r
    ld_r_ind_rr r, z80_h, z80_l
endmacro

macro ld_ind_abs_rr high_r, low_r
    ; TODO: What order do the bytes get stored in?
    set_operand_ptr_using_imm_16
    lda low_r
    sta (operand_ptr),y
    jsr bump_operand_ptr_y
    lda high_r
    sta (operand_ptr),y
    restore_pc_bank_and_y
    jmp dispatch_loop
endmacro

macro inc_rr high_r, low_r
    inc low_r
    bne no_carry
    inc high_r
.no_carry
    jmp dispatch_loop
endmacro

macro dec_rr high_r, low_r
    lda low_r
    bne no_borrow
    dec high_r
.no_borrow
    dec low_r
    jmp dispatch_loop
endmacro

macro and_6502_a
    and z80_a
    sta z80_a
    tax
    ; Clear N, C, set H and set S, Z, P according to result
    ; TODO: Probably elsewhere but we could probably replace a lot of this with table lookup - a table lookup can determine S and Z without needing to use the 6502 flags, this then handles S, Z and P in parallel
    php
    pla
    and #hybrid_flag_sz
    ora #hybrid_flag_h
    ora parity_table,x
    sta z80_f
    jmp dispatch_loop
endmacro

macro or_6502_a
    ora z80_a
    sta z80_a
    tax
    ; Clear H, N, C and set S, Z, P according to result
    php
    pla
    and #hybrid_flag_sz
    ora parity_table,x
    sta z80_f
    jmp dispatch_loop
endmacro

macro xor_6502_a
    eor z80_a
    sta z80_a
    tax
    ; TODO: As in some other places, the entire flag determination can probably be done by a single lookup table here
    ; Clear H, N, C and set S, Z, P according to result
    php
    pla
    and #hybrid_flag_sz
    ora parity_table,x
    sta z80_f
    jmp dispatch_loop
endmacro

macro cp_6502_a
    ; TODO: Far from confident about the correctness of this!
    sta zp_tmp
    lda z80_a
    sec
    sbc zp_tmp
    php
    and #&0f
    sta zp_tmp + 1
    pla
    eor #hybrid_flag_c
    and #hybrid_flag_szpc
    ora #hybrid_flag_n
    sta z80_f
    lda z80_a
    and #&0f
    cmp zp_tmp + 1
    bcs no_half_carry
    lda z80_f
    ora #hybrid_flag_h
    sta z80_f
.no_half_carry
    jmp dispatch_loop
endmacro

macro jp
    advance_pc_and_load
    sta z80_pcl_tmp
    advance_pc_and_load
    sta z80_pch_logical
    ldy z80_pcl_tmp
    jmp update_z80_pch_physical_and_dispatch
endmacro

macro jp_flag_internal hybrid_flag, branch_if_set
    ; TODO: We could probably write some if-else macro code to optimise detection of bits which we can test by implicit-set-on-lda z80_f
    lda z80_f
    and #hybrid_flag
if branch_if_set
    beq no_branch
else
    bne no_branch
endif
    jp
.no_branch
    tya
    clc
    adc #3
    tay
    bcs carry
    jmp dispatch_loop_no_increment
.carry
    jmp new_pc_page_and_dispatch_loop_no_increment
endmacro

macro jp_flag_set hybrid_flag
    jp_flag_internal hybrid_flag, TRUE
endmacro

macro jp_flag_clear hybrid_flag
    jp_flag_internal hybrid_flag, FALSE
endmacro

macro call
    advance_pc_and_load
    sta z80_pcl_tmp
    advance_pc_and_load
    sta zp_tmp
    ; Push the address of the next instruction onto the stack.
    iny
    bne no_carry
    inc z80_pch_logical
.no_carry
    sty zp_tmp + 1
    push_corrupt_pc_bank_and_y z80_pch_logical, zp_tmp + 1
    lda zp_tmp
    sta z80_pch_logical
    ldy z80_pcl_tmp
    jmp update_z80_pch_physical_and_dispatch
endmacro

macro call_flag_internal hybrid_flag, branch_if_set
    ; TODO: We could probably write some if-else macro code to optimise detection of bits which we can test by implicit-set-on-lda z80_f - this could potentially be shared with jp_flag_internal
    lda z80_f
    and #hybrid_flag
if branch_if_set
    beq no_branch
else
    bne no_branch
endif
    call
.no_branch
    ; TODO: Following is duplicate of code in jp_flag_internal
    tya
    clc
    adc #3
    tay
    bcs carry
    jmp dispatch_loop_no_increment
.carry
    jmp new_pc_page_and_dispatch_loop_no_increment
endmacro

macro call_flag_set hybrid_flag
    call_flag_internal hybrid_flag, TRUE
endmacro

macro call_flag_clear hybrid_flag
    call_flag_internal hybrid_flag, FALSE
endmacro

macro ret
    pop_corrupt_pc_bank_and_y z80_pch_logical, z80_pcl_tmp
    ldy z80_pcl_tmp
    jmp update_z80_pch_physical_and_dispatch
endmacro

macro ret_flag_internal hybrid_flag, branch_if_set
    ; TODO: We could probably write some if-else macro code to optimise detection of bits which we can test by implicit-set-on-lda z80_f - this could potentially be shared with jp_flag_internal
    lda z80_f
    and #hybrid_flag
if branch_if_set
    beq no_branch
else
    bne no_branch
endif
    ret
.no_branch
    ; TODO: Following is duplicate of code in jp_flag_internal
    tya
    clc
    adc #3
    tay
    bcs carry
    jmp dispatch_loop_no_increment
.carry
    jmp new_pc_page_and_dispatch_loop_no_increment
endmacro

macro ret_flag_set hybrid_flag
    ret_flag_internal hybrid_flag, TRUE
endmacro

macro ret_flag_clear hybrid_flag
    ret_flag_internal hybrid_flag, FALSE
endmacro

macro push_internal high, low, save_pc_bank_and_y
if save_pc_bank_and_y
    store_pc_bank_and_y
endif
    sec
    lda z80_sp
    sbc #2
    sta z80_sp
    tay
    bcs no_borrow
    dec z80_sp + 1
.no_borrow
    lda z80_sp + 1
    jsr set_operand_ptr_using_a
    ; TODO: Which order do the bytes get pushed onto the stack? This order seems logical but may not be correct.
    lda low
    sta (operand_ptr),y
    jsr bump_operand_ptr_y
    lda high
    sta (operand_ptr),y
if save_pc_bank_and_y
    restore_pc_bank_and_y
endif
endmacro

macro push_corrupt_pc_bank_and_y high, low
    push_internal high, low, FALSE
endmacro

macro push high, low
    push_internal high, low, TRUE
endmacro

macro pop_internal high, low, save_pc_bank_and_y
if save_pc_bank_and_y
    store_pc_bank_and_y
endif
    lda z80_sp + 1
    jsr set_operand_ptr_using_a
    ldy z80_sp
    ; TODO: Which order do the bytes get popped off the stack? This order seems logical but may not be correct.
    lda (operand_ptr),y
    sta low
    jsr bump_operand_ptr_y
    lda (operand_ptr),y
    sta high
    clc
    lda z80_sp
    adc #2
    sta z80_sp
    bcc no_carry
    inc z80_sp + 1
.no_carry
if save_pc_bank_and_y
    restore_pc_bank_and_y
endif
endmacro

macro pop_corrupt_pc_bank_and_y high, low
    pop_internal high, low, FALSE
endmacro

macro pop high, low
    pop_internal high, low, TRUE
endmacro

macro ex_r_s_fragment r, s
    ldx s
    lda r
    stx r
    sta s
endmacro

macro ex_rr_ss r_high, r_low, s_high, s_low
    ex_r_s_fragment r_high, s_high
    ex_r_s_fragment r_low, s_low
    jmp dispatch_loop
endmacro

macro multibyte_dispatch low_table, high_table
    advance_pc_and_load
    asl a
    tax
    bcs top_bit_set
    jmp (low_table,x)
.top_bit_set
    jmp (high_table,x)
endmacro

macro dec_r r
    dec r
    lda z80_f
    and #hybrid_flag_c
    ldx r
    ora dec_flag_table,x
    sta z80_f
    jmp dispatch_loop
endmacro

macro inc_r_fragment r
    inc r
    lda z80_f
    and #hybrid_flag_c
    ldx r
    ora inc_flag_table,x
    sta z80_f
endmacro

macro inc_r r
    inc_r_fragment r
    jmp dispatch_loop
endmacro

; Instruction: nop
.opcode_handler_nop
.opcode_handler_00
    jmp dispatch_loop

; Instruction: ld bc,**
.opcode_handler_01
    ld_rr_16 z80_b, z80_c

; Instruction: inc bc
.opcode_handler_03
    inc_rr z80_b, z80_c

; Instruction: dec b
.opcode_handler_05
    dec_r z80_b

; Instruction: ld b,*
.opcode_handler_06
    ld_r_8 z80_b

; Instruction: rlca
.opcode_handler_07
    lda z80_a
    cmp #&80
    rol a
    sta z80_a
    lda z80_f
    and_not hybrid_flag_hnc
    assert hybrid_flag_c == 1
    adc #0
    sta z80_f
    jmp dispatch_loop

macro add_rr_ss r_high, r_low, s_high, s_low
    ; Note that r and s may be the same, so we can't assume s_high is unchanged
    ; when we come to determine H. There's no harm in doing this step first
    ; anyway.
    ; TODO: Far from confident the flag handling here is correct
    lda s_high
    and #&0f
    sta zp_tmp + 1
    clc
    lda r_low
    adc s_low
    sta r_low
    php
    lda r_high
    tax
    adc s_high
    sta r_high
    lda z80_f
    and_not hybrid_flag_hnc
    ; TODO: Can we just do "adc #0" instead of this bcc:ora sequence?
    bcc no_carry
    ora #hybrid_flag_c
.no_carry
    sta z80_f
    txa
    and #&0f
    plp
    adc zp_tmp + 1
    and #&f0
    beq no_half_carry
    ; TODO: If we made H bit 0 of hybrid flags, we could replace the following three instructions with inc z80_f. Whether this is worthwhile depends on whether we use the 6502 C flag via php:pla to set the hybrid C flag at any point.
    lda z80_f
    ora #hybrid_flag_h
    sta z80_f
.no_half_carry
    jmp dispatch_loop
endmacro

macro adc_rr_ss r_high, r_low, s_high, s_low
    ; TODO: This is a super-inefficient implementation, let's get it correct before tuning it

    ; Note that r and s may be the same, so we can't assume s_high is unchanged
    ; when we come to determine H. There's no harm in doing this step first
    ; anyway.
    lda s_high
    and #&0f
    sta zp_tmp + 1

    ; Set 6502 carry based on Z80 carry.
    lda z80_f
    assert hybrid_flag_c == 1
    lsr a

    lda r_low
    adc s_low
    sta r_low
    php
    lda r_high
    tax
    adc s_high
    sta r_high

    ; take S, V, C from 6502 flags
    php
    pla
    ; force Z, H clear so we can choose to set them below and force N clear
    and_not hybrid_flag_zhn

    ; calculate H
    txa
    and #&0f
    plp
    adc zp_tmp + 1
    and #&f0
    beq no_half_carry
    ; TODO: If we made H bit 0 of hybrid flags, we could replace the following three instructions with inc z80_f. Whether this is worthwhile depends on whether we use the 6502 C flag via php:pla to set the hybrid C flag at any point.
    lda z80_f
    ora #hybrid_flag_h
    sta z80_f
.no_half_carry

    jmp dispatch_loop
endmacro

macro sbc_rr_ss r_high, r_low, s_high, s_low
    ; TODO: This is a super-inefficient implementation based on b-em's code; let's see if I can get this to pass some tests before trying to rewrite it to be modestly efficient.
    lda r_high
    sta zp_tmp + 1
    lda r_low
    sta zp_tmp

    ; Set 6502 carry based on Z80 carry.
    lda z80_f
    assert hybrid_flag_c == 1
    eor #1
    lsr a

    lda r_low
    sbc s_low
    sta r_low
    lda r_high
    sbc s_high
    sta r_high

    ; b-em-our variable correspondence:
    ; r = r_high/r_low
    ; b = s_high/s_low
    ; a = zp_tmp

    ; take S, V, C from 6502 flags
    php
    pla
    ; force Z, H clear so we can choose to set them below
    and_not hybrid_flag_zh
    ; force N on
    ora #hybrid_flag_n
    ; toggle 6502 carry to give Z80-style carry
    eor #hybrid_flag_c
    sta z80_f

    ; calculate H
    lda r_high
    eor s_high
    eor zp_tmp + 1
    and #1<<4
    beq no_half_carry
    lda z80_f
    ora #hybrid_flag_h
    sta z80_f
.no_half_carry

    ; calculate Z
    lda r_high
    ora r_low
    bne not_zero
    lda z80_f
    ora #hybrid_flag_z
    sta z80_f
.not_zero
    jmp dispatch_loop
endmacro

; Instruction: add hl,bc
.opcode_handler_09
    add_rr_ss z80_h, z80_l, z80_b, z80_c

; Instruction: dec bc
.opcode_handler_0b
    dec_rr z80_b, z80_c

; Instruction: dec c
.opcode_handler_0d
    dec_r z80_c

; Instruction: ld c,*
.opcode_handler_0e
    ld_r_8 z80_c

; Instruction: rrca
.opcode_handler_0f
    ; TODO: An 8-bit rotate could be done using a lookup table (also in rlca, if it's faster there)
    lda z80_a
    lsr a
    bcc top_bit_0
    ora #&80
.top_bit_0
    sta z80_a
    lda z80_f
    and_not hybrid_flag_hnc
    assert hybrid_flag_c == 1
    adc #0
    sta z80_f
    jmp dispatch_loop

; Instruction: ld de,**
.opcode_handler_11
    ld_rr_16 z80_d, z80_e

; Instruction: ld (de),a
.opcode_handler_12
    ld_ind_rr_r z80_d, z80_e, z80_a

; Instruction: inc de
.opcode_handler_13
    inc_rr z80_d, z80_e

; Instruction: inc d
.opcode_handler_14
    inc_r z80_d

; Instruction: ld d,*
.opcode_handler_16
    ld_r_8 z80_d

; Instruction: add hl,de
.opcode_handler_19
    add_rr_ss z80_h, z80_l, z80_d, z80_e

; Instruction: ld a,(de)
.opcode_handler_1a
    ld_r_ind_rr z80_a, z80_d, z80_e

; Instruction: dec de
.opcode_handler_1b
    dec_rr z80_d, z80_e

; Instruction: ld hl,**
.opcode_handler_21
    ld_rr_16 z80_h, z80_l

; Instruction: ld (**),hl
.opcode_handler_22
    ld_ind_abs_rr z80_h, z80_l

; Instruction: inc hl
.opcode_handler_23
    inc_rr z80_h, z80_l

; Instruction: ld h,*
.opcode_handler_26
    ld_r_8 z80_h

; Instruction: ld hl,(**)
.opcode_handler_2a
    ld_rr_ind_abs z80_h, z80_l

; Instruction: add hl,hl
.opcode_handler_29
    ; TODO: May be able to optimise implementation of this
    add_rr_ss z80_h, z80_l, z80_h, z80_l

; Instruction: dec hl
.opcode_handler_2b
    dec_rr z80_h, z80_l

; Instruction: ld sp,**
.opcode_handler_31
    ld_rr_16 z80_sp + 1, z80_sp

; Instruction: ld (**),a
.opcode_handler_32
    set_operand_ptr_using_imm_16
    lda z80_a
    sta (operand_ptr),y
    restore_pc_bank_and_y
    jmp dispatch_loop

; Instruction: inc sp
.opcode_handler_33
    inc_rr z80_sp + 1, z80_sp

; Instruction: inc (hl)
.opcode_handler_34
    ; TODO: This is probably storing and restoring pc bank and Y too often due to the component macros using them, but let's get it working before worrying about optimising this.
    lda_ind_hl
    ; TODO: storing this to zp_tmp to use inc_r is a bit crappy but again let's get it working before optimising
    sta zp_tmp
    inc_r_fragment zp_tmp
    ld_ind_hl_r zp_tmp

; Instruction: ld (hl),*
.opcode_handler_36
    advance_pc_and_load
    sta_ind_hl_via_tmp_fragment
    jmp dispatch_loop

; Instruction: add hl,sp
.opcode_handler_39
    add_rr_ss z80_h, z80_l, z80_sp + 1, z80_sp

; Instruction: ld a,(**)
.opcode_handler_3a
    set_operand_ptr_using_imm_16
    lda (operand_ptr),y
    sta z80_a
    restore_pc_bank_and_y
    jmp dispatch_loop

; Instruction: dec sp
.opcode_handler_3b
    dec_rr z80_sp + 1, z80_sp

; Instruction: inc a
.opcode_handler_3c
    inc_r z80_a

; Instruction: ld a,*
.opcode_handler_3e
    ld_r_8 z80_a

; Instruction: ld b,(hl)
.opcode_handler_46
    ld_r_ind_hl z80_b

; Instruction: ld b,a
.opcode_handler_47
    ld_r_s z80_b, z80_a

; Instruction: ld c,(hl)
.opcode_handler_4e
    ld_r_ind_hl z80_c

; Instruction: ld c,a
.opcode_handler_4f
    ld_r_s z80_c, z80_a

; Instruction: ld d,h
.opcode_handler_54
    ld_r_s z80_d, z80_h

; Instruction: ld d,(hl)
.opcode_handler_56
    ld_r_ind_hl z80_d

; Instruction: ld e,l
.opcode_handler_5d
    ld_r_s z80_e, z80_l

; Instruction: ld e,(hl)
.opcode_handler_5e
    ld_r_ind_hl z80_e

; Instruction: ld e,a
.opcode_handler_5f
    ld_r_s z80_e, z80_a

; Instruction: ld h,(hl)
.opcode_handler_66
    ld_r_ind_hl z80_h

; Instruction: ld l,(hl)
.opcode_handler_6e
    ld_r_ind_hl z80_l

; Instruction: ld l,a
.opcode_handler_6f
    ld_r_s z80_l, z80_a

; Instruction: ld (hl),a
.opcode_handler_77
    ld_ind_hl_r z80_a

; Instruction: ld a,b
.opcode_handler_78
    ld_r_s z80_a, z80_b

; Instruction: ld a,c
.opcode_handler_79
    ld_r_s z80_a, z80_c

; Instruction: ld a,d
.opcode_handler_7a
    ld_r_s z80_a, z80_d

; Instruction: ld a,e
.opcode_handler_7b
    ld_r_s z80_a, z80_e

; Instruction: ld a,(hl)
.opcode_handler_7e
    ld_r_ind_hl z80_a

; Instruction: ld a,a
.opcode_handler_7f
    jmp dispatch_loop

; Instruction: and b
.opcode_handler_a0
    lda z80_b
    and_6502_a

; Instruction: and c
.opcode_handler_a1
    lda z80_c
    and_6502_a

; Instruction: xor b
.opcode_handler_a8
    lda z80_b
    xor_6502_a

; Instruction: xor c
.opcode_handler_a9
    lda z80_c
    xor_6502_a

; Instruction: xor (hl)
.opcode_handler_ae
    lda_ind_hl
    xor_6502_a

; Instruction: xor a
.opcode_handler_af
    ; TODO: It might be possible to implement this specially
    lda z80_a
    xor_6502_a

; Instruction: or (hl)
.opcode_handler_b6
    lda_ind_hl
    or_6502_a

; Instruction: or a
.opcode_handler_b7
    ; TODO: It may be possible to implement this specially (we're or-ing a with itself)
    lda z80_a
    or_6502_a

; Instruction: cp (hl)
.opcode_handler_be
    lda_ind_hl
    cp_6502_a

; Instruction: pop bc
.opcode_handler_c1
    pop z80_b, z80_c
    jmp dispatch_loop

; Instruction: jp nz,**
.opcode_handler_c2
    jp_flag_clear hybrid_flag_z

; Instruction: jp **
.opcode_handler_c3
    jp

; Instruction: call nz,**
.opcode_handler_c4
    call_flag_clear hybrid_flag_z

; Instruction: push bc
.opcode_handler_c5
    push z80_b, z80_c
    jmp dispatch_loop

; Instruction: ret z
.opcode_handler_c8
    ret_flag_set hybrid_flag_z

; Instruction: ret
.opcode_handler_c9
    ret

; Instruction: jp z,**
.opcode_handler_ca
    jp_flag_set hybrid_flag_z

; Instruction: call **
.opcode_handler_cd
    call

; Instruction: pop de
.opcode_handler_d1
    pop z80_d, z80_e
    jmp dispatch_loop

; Instruction: push de
.opcode_handler_d5
    push z80_d, z80_e
    jmp dispatch_loop

; Instruction: jp c,**
.opcode_handler_da
    jp_flag_set hybrid_flag_c

; Instruction: call c,**
.opcode_handler_dc
    call_flag_set hybrid_flag_c

; Instruction: IX prefix
.opcode_handler_dd
    multibyte_dispatch dispatch_table_dd_low, dispatch_table_dd_high

; Instruction: pop hl
.opcode_handler_e1
    pop z80_h, z80_l
    jmp dispatch_loop

; Instruction: push hl
.opcode_handler_e5
    push z80_h, z80_l
    jmp dispatch_loop

; Instruction: and *
.opcode_handler_e6
    advance_pc_and_load
    and_6502_a

; Instruction: ex de,hl
.opcode_handler_eb
    ex_rr_ss z80_d, z80_e, z80_h, z80_l

; Instruction: EXTD prefix
.opcode_handler_ed
    multibyte_dispatch dispatch_table_ed_low, dispatch_table_ed_high

; Instruction: pop af
.opcode_handler_f1
    pop z80_a, zp_tmp
    ldx zp_tmp
    lda z80_to_hybrid_flag_table,x
    sta z80_f
    jmp dispatch_loop

; Instruction: di
.opcode_handler_f3
    ; TODO: Do we need to emulate anything re interrupts?
    jmp dispatch_loop

; Instruction: push af
.opcode_handler_f5
    ldx z80_f
    lda hybrid_to_z80_flag_table,x
    sta zp_tmp
    push z80_a, zp_tmp
    jmp dispatch_loop

; Instruction: ld sp,hl
.opcode_handler_f9
    ld_r_s_fragment z80_sp    , z80_l
    ld_r_s          z80_sp + 1, z80_h

; Instruction: ei
.opcode_handler_fb
    ; TODO: Anything to emulate re interrupts?
    jmp dispatch_loop

; Instruction: IY prefix
.opcode_handler_fd
    multibyte_dispatch dispatch_table_fd_low, dispatch_table_fd_high

; Instruction: cp *
.opcode_handler_fe
    advance_pc_and_load
    cp_6502_a

; Instruction: sbc hl,bc
.opcode_handler_ed_42
    sbc_rr_ss z80_h, z80_l, z80_b, z80_c

; Instruction: adc hl,bc
.opcode_handler_ed_4a
    adc_rr_ss z80_h, z80_l, z80_b, z80_c

; Instruction: sbc hl,hl
.opcode_handler_ed_62
    ; TODO: I have no idea if this instruction is actually common but if it is its implementation can probably be specialised, since I *suspect* (haven't checked) its result only boils down to the current state of the carry
    sbc_rr_ss z80_h, z80_l, z80_h, z80_l

; Instruction: adc hl,hl
.opcode_handler_ed_6a
    ; TODO: It may be possible to optimise this instruction - not necessarily, but it may be its doubling-plus-carry nature means we can avoid some of the inefficiencies normally needed
    adc_rr_ss z80_h, z80_l, z80_h, z80_l

; Instruction: ld (**),sp
.opcode_handler_ed_73
    ld_ind_abs_rr z80_sp + 1, z80_sp

; Instruction: ld sp,(**)
.opcode_handler_ed_7b
    ld_rr_ind_abs z80_sp + 1, z80_sp

; Instruction: ldir
.opcode_handler_ed_b0
{
    store_pc_bank_and_y
.loop
    lda z80_h
    jsr set_operand_ptr_using_a
    ldy z80_l
    lda (operand_ptr),y
    sta zp_tmp
    lda z80_d
    jsr set_operand_ptr_using_a
    ldy z80_e
    lda zp_tmp
    sta (operand_ptr),y
    inc z80_e
    bne no_carry_de
    inc z80_d
.no_carry_de
    inc z80_l
    bne no_carry_hl
    inc z80_h
.no_carry_hl
    lda z80_c
    bne no_borrow_bc
    dec z80_b
.no_borrow_bc
    dec z80_c
    bne loop
    lda z80_b
    bne loop
    lda z80_f
    and_not hybrid_flag_hpn
    sta z80_f
    restore_pc_bank_and_y
    jmp dispatch_loop
}

; Instruction: pop ix
.opcode_handler_dd_e1
    pop z80_ix + 1, z80_ix
    jmp dispatch_loop

; Instruction: push ix
.opcode_handler_dd_e5
    push z80_ix + 1, z80_ix
    jmp dispatch_loop

; Instruction: pop iy
.opcode_handler_fd_e1
    pop z80_iy + 1, z80_iy
    jmp dispatch_loop

; Instruction: push iy
.opcode_handler_fd_e5
    push z80_iy + 1, z80_iy
    jmp dispatch_loop

; TODO: Temporary hack to emulate bdos functions necessary for test code
.bdos_emulation
    lda z80_c
    cmp #9
    beq bdos_emulation_writestr
    brk
.bdos_emulation_writestr
{
    lda z80_d
    jsr set_operand_ptr_using_a
    ldy z80_e
.loop
    lda (operand_ptr),y
    cmp #'$'
    beq done
    jsr osasci
    jsr bump_operand_ptr_y
    jmp loop
.done
    jmp opcode_handler_c9
}


    align &100
.dispatch_table_low
    equw opcode_handler_00
    equw opcode_handler_01
    equw opcode_todo ; &02
    equw opcode_handler_03
    equw opcode_todo ; &04
    equw opcode_handler_05
    equw opcode_handler_06
    equw opcode_handler_07
    equw opcode_todo ; &08
    equw opcode_handler_09
    equw opcode_todo ; &0a
    equw opcode_handler_0b
    equw opcode_todo ; &0c
    equw opcode_handler_0d
    equw opcode_handler_0e
    equw opcode_handler_0f
    equw opcode_todo ; &10
    equw opcode_handler_11
    equw opcode_handler_12
    equw opcode_handler_13
    equw opcode_handler_14
    equw opcode_todo ; &15
    equw opcode_handler_16
    equw opcode_todo ; &17
    equw opcode_todo ; &18
    equw opcode_handler_19
    equw opcode_handler_1a
    equw opcode_handler_1b
    equw opcode_todo ; &1c
    equw opcode_todo ; &1d
    equw opcode_todo ; &1e
    equw opcode_todo ; &1f
    equw opcode_todo ; &20
    equw opcode_handler_21
    equw opcode_handler_22
    equw opcode_handler_23
    equw opcode_todo ; &24
    equw opcode_todo ; &25
    equw opcode_handler_26
    equw opcode_todo ; &27
    equw opcode_todo ; &28
    equw opcode_handler_29
    equw opcode_handler_2a
    equw opcode_handler_2b
    equw opcode_todo ; &2c
    equw opcode_todo ; &2d
    equw opcode_todo ; &2e
    equw opcode_todo ; &2f
    equw opcode_todo ; &30
    equw opcode_handler_31
    equw opcode_handler_32
    equw opcode_handler_33
    equw opcode_handler_34
    equw opcode_todo ; &35
    equw opcode_handler_36
    equw opcode_todo ; &37
    equw opcode_todo ; &38
    equw opcode_handler_39
    equw opcode_handler_3a
    equw opcode_handler_3b
    equw opcode_handler_3c
    equw opcode_todo ; &3d
    equw opcode_handler_3e
    equw opcode_todo ; &3f
    equw opcode_todo ; &40
    equw opcode_todo ; &41
    equw opcode_todo ; &42
    equw opcode_todo ; &43
    equw opcode_todo ; &44
    equw opcode_todo ; &45
    equw opcode_handler_46
    equw opcode_handler_47
    equw opcode_todo ; &48
    equw opcode_todo ; &49
    equw opcode_todo ; &4a
    equw opcode_todo ; &4b
    equw opcode_todo ; &4c
    equw opcode_todo ; &4d
    equw opcode_handler_4e
    equw opcode_handler_4f
    equw opcode_todo ; &50
    equw opcode_todo ; &51
    equw opcode_todo ; &52
    equw opcode_todo ; &53
    equw opcode_handler_54
    equw opcode_todo ; &55
    equw opcode_handler_56
    equw opcode_todo ; &57
    equw opcode_todo ; &58
    equw opcode_todo ; &59
    equw opcode_todo ; &5a
    equw opcode_todo ; &5b
    equw opcode_todo ; &5c
    equw opcode_handler_5d
    equw opcode_handler_5e
    equw opcode_handler_5f
    equw opcode_todo ; &60
    equw opcode_todo ; &61
    equw opcode_todo ; &62
    equw opcode_todo ; &63
    equw opcode_todo ; &64
    equw opcode_todo ; &65
    equw opcode_handler_66
    equw opcode_todo ; &67
    equw opcode_todo ; &68
    equw opcode_todo ; &69
    equw opcode_todo ; &6a
    equw opcode_todo ; &6b
    equw opcode_todo ; &6c
    equw opcode_todo ; &6d
    equw opcode_handler_6e
    equw opcode_handler_6f
    equw opcode_todo ; &70
    equw opcode_todo ; &71
    equw opcode_todo ; &72
    equw opcode_todo ; &73
    equw opcode_todo ; &74
    equw opcode_todo ; &75
    equw opcode_todo ; &76
    equw opcode_handler_77
    equw opcode_handler_78
    equw opcode_handler_79
    equw opcode_handler_7a
    equw opcode_handler_7b
    equw opcode_todo ; &7c
    equw opcode_todo ; &7d
    equw opcode_handler_7e
    equw opcode_handler_7f
.dispatch_table_high
    equw opcode_todo ; &80
    equw opcode_todo ; &81
    equw opcode_todo ; &82
    equw opcode_todo ; &83
    equw opcode_todo ; &84
    equw opcode_todo ; &85
    equw opcode_todo ; &86
    equw opcode_todo ; &87
    equw opcode_todo ; &88
    equw opcode_todo ; &89
    equw opcode_todo ; &8a
    equw opcode_todo ; &8b
    equw opcode_todo ; &8c
    equw opcode_todo ; &8d
    equw opcode_todo ; &8e
    equw opcode_todo ; &8f
    equw opcode_todo ; &90
    equw opcode_todo ; &91
    equw opcode_todo ; &92
    equw opcode_todo ; &93
    equw opcode_todo ; &94
    equw opcode_todo ; &95
    equw opcode_todo ; &96
    equw opcode_todo ; &97
    equw opcode_todo ; &98
    equw opcode_todo ; &99
    equw opcode_todo ; &9a
    equw opcode_todo ; &9b
    equw opcode_todo ; &9c
    equw opcode_todo ; &9d
    equw opcode_todo ; &9e
    equw opcode_todo ; &9f
    equw opcode_handler_a0
    equw opcode_handler_a1
    equw opcode_todo ; &a2
    equw opcode_todo ; &a3
    equw opcode_todo ; &a4
    equw opcode_todo ; &a5
    equw opcode_todo ; &a6
    equw opcode_todo ; &a7
    equw opcode_handler_a8
    equw opcode_handler_a9
    equw opcode_todo ; &aa
    equw opcode_todo ; &ab
    equw opcode_todo ; &ac
    equw opcode_todo ; &ad
    equw opcode_handler_ae
    equw opcode_handler_af
    equw opcode_todo ; &b0
    equw opcode_todo ; &b1
    equw opcode_todo ; &b2
    equw opcode_todo ; &b3
    equw opcode_todo ; &b4
    equw opcode_todo ; &b5
    equw opcode_handler_b6
    equw opcode_handler_b7
    equw opcode_todo ; &b8
    equw opcode_todo ; &b9
    equw opcode_todo ; &ba
    equw opcode_todo ; &bb
    equw opcode_todo ; &bc
    equw opcode_todo ; &bd
    equw opcode_handler_be
    equw opcode_todo ; &bf
    equw opcode_todo ; &c0
    equw opcode_handler_c1
    equw opcode_handler_c2
    equw opcode_handler_c3
    equw opcode_handler_c4
    equw opcode_handler_c5
    equw opcode_todo ; &c6
    equw opcode_todo ; &c7
    equw opcode_handler_c8
    equw opcode_handler_c9
    equw opcode_handler_ca
    equw opcode_todo ; &cb
    equw opcode_todo ; &cc
    equw opcode_handler_cd
    equw opcode_todo ; &ce
    equw opcode_todo ; &cf
    equw opcode_todo ; &d0
    equw opcode_handler_d1
    equw opcode_todo ; &d2
    equw opcode_todo ; &d3
    equw opcode_todo ; &d4
    equw opcode_handler_d5
    equw opcode_todo ; &d6
    equw opcode_todo ; &d7
    equw opcode_todo ; &d8
    equw opcode_todo ; &d9
    equw opcode_handler_da
    equw opcode_todo ; &db
    equw opcode_handler_dc
    equw opcode_handler_dd
    equw opcode_todo ; &de
    equw opcode_todo ; &df
    equw opcode_todo ; &e0
    equw opcode_handler_e1
    equw opcode_todo ; &e2
    equw opcode_todo ; &e3
    equw opcode_todo ; &e4
    equw opcode_handler_e5
    equw opcode_handler_e6
    equw opcode_todo ; &e7
    equw opcode_todo ; &e8
    equw opcode_todo ; &e9
    equw opcode_todo ; &ea
    equw opcode_handler_eb
    equw opcode_todo ; &ec
    equw opcode_handler_ed
    equw opcode_todo ; &ee
    equw opcode_todo ; &ef
    equw opcode_todo ; &f0
    equw opcode_handler_f1
    equw opcode_todo ; &f2
    equw opcode_handler_f3
    equw opcode_todo ; &f4
    equw opcode_handler_f5
    equw opcode_todo ; &f6
    equw opcode_todo ; &f7
    equw opcode_todo ; &f8
    equw opcode_handler_f9
    equw opcode_todo ; &fa
    equw opcode_handler_fb
    equw opcode_todo ; &fc
    equw opcode_handler_fd
    equw opcode_handler_fe
    equw opcode_todo ; &ff

    align &100
.dispatch_table_ed_low
    equw opcode_todo  ; &00
    equw opcode_todo  ; &01
    equw opcode_todo  ; &02
    equw opcode_todo  ; &03
    equw opcode_todo  ; &04
    equw opcode_todo  ; &05
    equw opcode_todo  ; &06
    equw opcode_todo  ; &07
    equw opcode_todo  ; &08
    equw opcode_todo  ; &09
    equw opcode_todo  ; &0a
    equw opcode_todo  ; &0b
    equw opcode_todo  ; &0c
    equw opcode_todo  ; &0d
    equw opcode_todo  ; &0e
    equw opcode_todo  ; &0f
    equw opcode_todo  ; &10
    equw opcode_todo  ; &11
    equw opcode_todo  ; &12
    equw opcode_todo  ; &13
    equw opcode_todo  ; &14
    equw opcode_todo  ; &15
    equw opcode_todo  ; &16
    equw opcode_todo  ; &17
    equw opcode_todo  ; &18
    equw opcode_todo  ; &19
    equw opcode_todo  ; &1a
    equw opcode_todo  ; &1b
    equw opcode_todo  ; &1c
    equw opcode_todo  ; &1d
    equw opcode_todo  ; &1e
    equw opcode_todo  ; &1f
    equw opcode_todo  ; &20
    equw opcode_todo  ; &21
    equw opcode_todo  ; &22
    equw opcode_todo  ; &23
    equw opcode_todo  ; &24
    equw opcode_todo  ; &25
    equw opcode_todo  ; &26
    equw opcode_todo  ; &27
    equw opcode_todo  ; &28
    equw opcode_todo  ; &29
    equw opcode_todo  ; &2a
    equw opcode_todo  ; &2b
    equw opcode_todo  ; &2c
    equw opcode_todo  ; &2d
    equw opcode_todo  ; &2e
    equw opcode_todo  ; &2f
    equw opcode_todo  ; &30
    equw opcode_todo  ; &31
    equw opcode_todo  ; &32
    equw opcode_todo  ; &33
    equw opcode_todo  ; &34
    equw opcode_todo  ; &35
    equw opcode_todo  ; &36
    equw opcode_todo  ; &37
    equw opcode_todo  ; &38
    equw opcode_todo  ; &39
    equw opcode_todo  ; &3a
    equw opcode_todo  ; &3b
    equw opcode_todo  ; &3c
    equw opcode_todo  ; &3d
    equw opcode_todo  ; &3e
    equw opcode_todo  ; &3f
    equw opcode_todo  ; &40
    equw opcode_todo  ; &41
    equw opcode_handler_ed_42
    equw opcode_todo  ; &43
    equw opcode_todo  ; &44
    equw opcode_todo  ; &45
    equw opcode_todo  ; &46
    equw opcode_todo  ; &47
    equw opcode_todo  ; &48
    equw opcode_todo  ; &49
    equw opcode_handler_ed_4a
    equw opcode_todo  ; &4b
    equw opcode_todo  ; &4c
    equw opcode_todo  ; &4d
    equw opcode_todo  ; &4e
    equw opcode_todo  ; &4f
    equw opcode_todo  ; &50
    equw opcode_todo  ; &51
    equw opcode_todo  ; &52
    equw opcode_todo  ; &53
    equw opcode_todo  ; &54
    equw opcode_todo  ; &55
    equw opcode_todo  ; &56
    equw opcode_todo  ; &57
    equw opcode_todo  ; &58
    equw opcode_todo  ; &59
    equw opcode_todo  ; &5a
    equw opcode_todo  ; &5b
    equw opcode_todo  ; &5c
    equw opcode_todo  ; &5d
    equw opcode_todo  ; &5e
    equw opcode_todo  ; &5f
    equw opcode_todo  ; &60
    equw opcode_todo  ; &61
    equw opcode_handler_ed_62
    equw opcode_todo  ; &63
    equw opcode_todo  ; &64
    equw opcode_todo  ; &65
    equw opcode_todo  ; &66
    equw opcode_todo  ; &67
    equw opcode_todo  ; &68
    equw opcode_todo  ; &69
    equw opcode_handler_ed_6a
    equw opcode_todo  ; &6b
    equw opcode_todo  ; &6c
    equw opcode_todo  ; &6d
    equw opcode_todo  ; &6e
    equw opcode_todo  ; &6f
    equw opcode_todo  ; &70
    equw opcode_todo  ; &71
    equw opcode_todo  ; &72
    equw opcode_handler_ed_73
    equw opcode_todo  ; &74
    equw opcode_todo  ; &75
    equw opcode_todo  ; &76
    equw opcode_todo  ; &77
    equw opcode_todo  ; &78
    equw opcode_todo  ; &79
    equw opcode_todo  ; &7a
    equw opcode_handler_ed_7b
    equw opcode_todo  ; &7c
    equw opcode_todo  ; &7d
    equw opcode_todo  ; &7e
    equw opcode_todo  ; &7f
.dispatch_table_ed_high
    equw opcode_todo  ; &80
    equw opcode_todo  ; &81
    equw opcode_todo  ; &82
    equw opcode_todo  ; &83
    equw opcode_todo  ; &84
    equw opcode_todo  ; &85
    equw opcode_todo  ; &86
    equw opcode_todo  ; &87
    equw opcode_todo  ; &88
    equw opcode_todo  ; &89
    equw opcode_todo  ; &8a
    equw opcode_todo  ; &8b
    equw opcode_todo  ; &8c
    equw opcode_todo  ; &8d
    equw opcode_todo  ; &8e
    equw opcode_todo  ; &8f
    equw opcode_todo  ; &90
    equw opcode_todo  ; &91
    equw opcode_todo  ; &92
    equw opcode_todo  ; &93
    equw opcode_todo  ; &94
    equw opcode_todo  ; &95
    equw opcode_todo  ; &96
    equw opcode_todo  ; &97
    equw opcode_todo  ; &98
    equw opcode_todo  ; &99
    equw opcode_todo  ; &9a
    equw opcode_todo  ; &9b
    equw opcode_todo  ; &9c
    equw opcode_todo  ; &9d
    equw opcode_todo  ; &9e
    equw opcode_todo  ; &9f
    equw opcode_todo  ; &a0
    equw opcode_todo  ; &a1
    equw opcode_todo  ; &a2
    equw opcode_todo  ; &a3
    equw opcode_todo  ; &a4
    equw opcode_todo  ; &a5
    equw opcode_todo  ; &a6
    equw opcode_todo  ; &a7
    equw opcode_todo  ; &a8
    equw opcode_todo  ; &a9
    equw opcode_todo  ; &aa
    equw opcode_todo  ; &ab
    equw opcode_todo  ; &ac
    equw opcode_todo  ; &ad
    equw opcode_todo  ; &ae
    equw opcode_todo  ; &af
    equw opcode_handler_ed_b0
    equw opcode_todo  ; &b1
    equw opcode_todo  ; &b2
    equw opcode_todo  ; &b3
    equw opcode_todo  ; &b4
    equw opcode_todo  ; &b5
    equw opcode_todo  ; &b6
    equw opcode_todo  ; &b7
    equw opcode_todo  ; &b8
    equw opcode_todo  ; &b9
    equw opcode_todo  ; &ba
    equw opcode_todo  ; &bb
    equw opcode_todo  ; &bc
    equw opcode_todo  ; &bd
    equw opcode_todo  ; &be
    equw opcode_todo  ; &bf
    equw opcode_todo  ; &c0
    equw opcode_todo  ; &c1
    equw opcode_handler_nop   ; &c2
    equw opcode_todo  ; &c3
    equw opcode_todo  ; &c4
    equw opcode_todo  ; &c5
    equw opcode_todo  ; &c6
    equw opcode_todo  ; &c7
    equw opcode_todo  ; &c8
    equw opcode_todo  ; &c9
    equw opcode_handler_nop  ; &ca
    equw opcode_todo  ; &cb
    equw opcode_todo  ; &cc
    equw opcode_todo  ; &cd
    equw opcode_todo  ; &ce
    equw opcode_todo  ; &cf
    equw opcode_todo  ; &d0
    equw opcode_todo  ; &d1
    equw opcode_todo  ; &d2
    equw opcode_todo  ; &d3
    equw opcode_todo  ; &d4
    equw opcode_todo  ; &d5
    equw opcode_todo  ; &d6
    equw opcode_todo  ; &d7
    equw opcode_todo  ; &d8
    equw opcode_todo  ; &d9
    equw opcode_todo  ; &da
    equw opcode_todo  ; &db
    equw opcode_todo  ; &dc
    equw opcode_todo  ; &dd
    equw opcode_todo  ; &de
    equw opcode_todo  ; &df
    equw opcode_todo  ; &e0
    equw opcode_todo  ; &e1
    equw opcode_handler_nop  ; &e2
    equw opcode_handler_nop  ; &e3
    equw opcode_todo  ; &e4
    equw opcode_todo  ; &e5
    equw opcode_todo  ; &e6
    equw opcode_todo  ; &e7
    equw opcode_todo  ; &e8
    equw opcode_todo  ; &e9
    equw opcode_handler_nop  ; &ea
    equw opcode_todo  ; &eb
    equw opcode_todo  ; &ec
    equw opcode_todo  ; &ed
    equw opcode_todo  ; &ee
    equw opcode_todo  ; &ef
    equw opcode_todo  ; &f0
    equw opcode_todo  ; &f1
    equw opcode_todo  ; &f2
    equw opcode_todo  ; &f3
    equw opcode_todo  ; &f4
    equw opcode_todo  ; &f5
    equw opcode_todo  ; &f6
    equw opcode_todo  ; &f7
    equw opcode_todo  ; &f8
    equw opcode_todo  ; &f9
    equw opcode_todo  ; &fa
    equw opcode_todo  ; &fb
    equw opcode_todo  ; &fc
    equw opcode_todo  ; &fd
    equw opcode_todo  ; &fe
    equw opcode_todo  ; &ff

    align &100
.dispatch_table_dd_low
    equw opcode_todo  ; 00
    equw opcode_todo  ; 01
    equw opcode_todo  ; 02
    equw opcode_todo  ; 03
    equw opcode_todo  ; 04
    equw opcode_todo  ; 05
    equw opcode_todo  ; 06
    equw opcode_todo  ; 07
    equw opcode_todo  ; 08
    equw opcode_todo  ; 09
    equw opcode_todo  ; 0a
    equw opcode_todo  ; 0b
    equw opcode_todo  ; 0c
    equw opcode_todo  ; 0d
    equw opcode_todo  ; 0e
    equw opcode_todo  ; 0f
    equw opcode_todo  ; 10
    equw opcode_todo  ; 11
    equw opcode_todo  ; 12
    equw opcode_todo  ; 13
    equw opcode_todo  ; 14
    equw opcode_todo  ; 15
    equw opcode_todo  ; 16
    equw opcode_todo  ; 17
    equw opcode_todo  ; 18
    equw opcode_todo  ; 19
    equw opcode_todo  ; 1a
    equw opcode_todo  ; 1b
    equw opcode_todo  ; 1c
    equw opcode_todo  ; 1d
    equw opcode_todo  ; 1e
    equw opcode_todo  ; 1f
    equw opcode_todo  ; 20
    equw opcode_todo  ; 21
    equw opcode_todo  ; 22
    equw opcode_todo  ; 23
    equw opcode_todo  ; 24
    equw opcode_todo  ; 25
    equw opcode_todo  ; 26
    equw opcode_todo  ; 27
    equw opcode_todo  ; 28
    equw opcode_todo  ; 29
    equw opcode_todo  ; 2a
    equw opcode_todo  ; 2b
    equw opcode_todo  ; 2c
    equw opcode_todo  ; 2d
    equw opcode_todo  ; 2e
    equw opcode_todo  ; 2f
    equw opcode_todo  ; 30
    equw opcode_todo  ; 31
    equw opcode_todo  ; 32
    equw opcode_todo  ; 33
    equw opcode_todo  ; 34
    equw opcode_todo  ; 35
    equw opcode_todo  ; 36
    equw opcode_todo  ; 37
    equw opcode_todo  ; 38
    equw opcode_todo  ; 39
    equw opcode_todo  ; 3a
    equw opcode_todo  ; 3b
    equw opcode_todo  ; 3c
    equw opcode_todo  ; 3d
    equw opcode_todo  ; 3e
    equw opcode_todo  ; 3f
    equw opcode_todo  ; 40
    equw opcode_todo  ; 41
    equw opcode_todo  ; 42
    equw opcode_todo  ; 43
    equw opcode_todo  ; 44
    equw opcode_todo  ; 45
    equw opcode_todo  ; 46
    equw opcode_todo  ; 47
    equw opcode_todo  ; 48
    equw opcode_todo  ; 49
    equw opcode_todo  ; 4a
    equw opcode_todo  ; 4b
    equw opcode_todo  ; 4c
    equw opcode_todo  ; 4d
    equw opcode_todo  ; 4e
    equw opcode_todo  ; 4f
    equw opcode_todo  ; 50
    equw opcode_todo  ; 51
    equw opcode_todo  ; 52
    equw opcode_todo  ; 53
    equw opcode_todo  ; 54
    equw opcode_todo  ; 55
    equw opcode_todo  ; 56
    equw opcode_todo  ; 57
    equw opcode_todo  ; 58
    equw opcode_todo  ; 59
    equw opcode_todo  ; 5a
    equw opcode_todo  ; 5b
    equw opcode_todo  ; 5c
    equw opcode_todo  ; 5d
    equw opcode_todo  ; 5e
    equw opcode_todo  ; 5f
    equw opcode_todo  ; 60
    equw opcode_todo  ; 61
    equw opcode_todo  ; 62
    equw opcode_todo  ; 63
    equw opcode_todo  ; 64
    equw opcode_todo  ; 65
    equw opcode_todo  ; 66
    equw opcode_todo  ; 67
    equw opcode_todo  ; 68
    equw opcode_todo  ; 69
    equw opcode_todo  ; 6a
    equw opcode_todo  ; 6b
    equw opcode_todo  ; 6c
    equw opcode_todo  ; 6d
    equw opcode_todo  ; 6e
    equw opcode_todo  ; 6f
    equw opcode_todo  ; 70
    equw opcode_todo  ; 71
    equw opcode_todo  ; 72
    equw opcode_todo  ; 73
    equw opcode_todo  ; 74
    equw opcode_todo  ; 75
    equw opcode_todo  ; 76
    equw opcode_todo  ; 77
    equw opcode_todo  ; 78
    equw opcode_todo  ; 79
    equw opcode_todo  ; 7a
    equw opcode_todo  ; 7b
    equw opcode_todo  ; 7c
    equw opcode_todo  ; 7d
    equw opcode_todo  ; 7e
    equw opcode_todo  ; 7f
.dispatch_table_dd_high
    equw opcode_todo  ; 80
    equw opcode_todo  ; 81
    equw opcode_todo  ; 82
    equw opcode_todo  ; 83
    equw opcode_todo  ; 84
    equw opcode_todo  ; 85
    equw opcode_todo  ; 86
    equw opcode_todo  ; 87
    equw opcode_todo  ; 88
    equw opcode_todo  ; 89
    equw opcode_todo  ; 8a
    equw opcode_todo  ; 8b
    equw opcode_todo  ; 8c
    equw opcode_todo  ; 8d
    equw opcode_todo  ; 8e
    equw opcode_todo  ; 8f
    equw opcode_todo  ; 90
    equw opcode_todo  ; 91
    equw opcode_todo  ; 92
    equw opcode_todo  ; 93
    equw opcode_todo  ; 94
    equw opcode_todo  ; 95
    equw opcode_todo  ; 96
    equw opcode_todo  ; 97
    equw opcode_todo  ; 98
    equw opcode_todo  ; 99
    equw opcode_todo  ; 9a
    equw opcode_todo  ; 9b
    equw opcode_todo  ; 9c
    equw opcode_todo  ; 9d
    equw opcode_todo  ; 9e
    equw opcode_todo  ; 9f
    equw opcode_todo  ; a0
    equw opcode_todo  ; a1
    equw opcode_todo  ; a2
    equw opcode_todo  ; a3
    equw opcode_todo  ; a4
    equw opcode_todo  ; a5
    equw opcode_todo  ; a6
    equw opcode_todo  ; a7
    equw opcode_todo  ; a8
    equw opcode_todo  ; a9
    equw opcode_todo  ; aa
    equw opcode_todo  ; ab
    equw opcode_todo  ; ac
    equw opcode_todo  ; ad
    equw opcode_todo  ; ae
    equw opcode_todo  ; af
    equw opcode_todo  ; b0
    equw opcode_todo  ; b1
    equw opcode_todo  ; b2
    equw opcode_todo  ; b3
    equw opcode_todo  ; b4
    equw opcode_todo  ; b5
    equw opcode_todo  ; b6
    equw opcode_todo  ; b7
    equw opcode_todo  ; b8
    equw opcode_todo  ; b9
    equw opcode_todo  ; ba
    equw opcode_todo  ; bb
    equw opcode_todo  ; bc
    equw opcode_todo  ; bd
    equw opcode_todo  ; be
    equw opcode_todo  ; bf
    equw opcode_todo  ; c0
    equw opcode_todo  ; c1
    equw opcode_todo  ; c2
    equw opcode_todo  ; c3
    equw opcode_todo  ; c4
    equw opcode_todo  ; c5
    equw opcode_todo  ; c6
    equw opcode_todo  ; c7
    equw opcode_todo  ; c8
    equw opcode_todo  ; c9
    equw opcode_todo  ; ca
    equw opcode_todo  ; cb
    equw opcode_todo  ; cc
    equw opcode_todo  ; cd
    equw opcode_todo  ; ce
    equw opcode_todo  ; cf
    equw opcode_todo  ; d0
    equw opcode_todo  ; d1
    equw opcode_todo  ; d2
    equw opcode_todo  ; d3
    equw opcode_todo  ; d4
    equw opcode_todo  ; d5
    equw opcode_todo  ; d6
    equw opcode_todo  ; d7
    equw opcode_todo  ; d8
    equw opcode_todo  ; d9
    equw opcode_todo  ; da
    equw opcode_todo  ; db
    equw opcode_todo  ; dc
    equw opcode_todo  ; dd
    equw opcode_todo  ; de
    equw opcode_todo  ; df
    equw opcode_todo  ; e0
    equw opcode_handler_dd_e1
    equw opcode_todo  ; e2
    equw opcode_todo  ; e3
    equw opcode_todo  ; e4
    equw opcode_handler_dd_e5
    equw opcode_todo  ; e6
    equw opcode_todo  ; e7
    equw opcode_todo  ; e8
    equw opcode_todo  ; e9
    equw opcode_todo  ; ea
    equw opcode_todo  ; eb
    equw opcode_todo  ; ec
    equw opcode_todo  ; ed
    equw opcode_todo  ; ee
    equw opcode_todo  ; ef
    equw opcode_todo  ; f0
    equw opcode_todo  ; f1
    equw opcode_todo  ; f2
    equw opcode_todo  ; f3
    equw opcode_todo  ; f4
    equw opcode_todo  ; f5
    equw opcode_todo  ; f6
    equw opcode_todo  ; f7
    equw opcode_todo  ; f8
    equw opcode_todo  ; f9
    equw opcode_todo  ; fa
    equw opcode_todo  ; fb
    equw opcode_todo  ; fc
    equw opcode_todo  ; fd
    equw opcode_todo  ; fe
    equw opcode_todo  ; ff

    align &100
.dispatch_table_fd_low
    equw opcode_todo  ; 00
    equw opcode_todo  ; 01
    equw opcode_todo  ; 02
    equw opcode_todo  ; 03
    equw opcode_todo  ; 04
    equw opcode_todo  ; 05
    equw opcode_todo  ; 06
    equw opcode_todo  ; 07
    equw opcode_todo  ; 08
    equw opcode_todo  ; 09
    equw opcode_todo  ; 0a
    equw opcode_todo  ; 0b
    equw opcode_todo  ; 0c
    equw opcode_todo  ; 0d
    equw opcode_todo  ; 0e
    equw opcode_todo  ; 0f
    equw opcode_todo  ; 10
    equw opcode_todo  ; 11
    equw opcode_todo  ; 12
    equw opcode_todo  ; 13
    equw opcode_todo  ; 14
    equw opcode_todo  ; 15
    equw opcode_todo  ; 16
    equw opcode_todo  ; 17
    equw opcode_todo  ; 18
    equw opcode_todo  ; 19
    equw opcode_todo  ; 1a
    equw opcode_todo  ; 1b
    equw opcode_todo  ; 1c
    equw opcode_todo  ; 1d
    equw opcode_todo  ; 1e
    equw opcode_todo  ; 1f
    equw opcode_todo  ; 20
    equw opcode_todo  ; 21
    equw opcode_todo  ; 22
    equw opcode_todo  ; 23
    equw opcode_todo  ; 24
    equw opcode_todo  ; 25
    equw opcode_todo  ; 26
    equw opcode_todo  ; 27
    equw opcode_todo  ; 28
    equw opcode_todo  ; 29
    equw opcode_todo  ; 2a
    equw opcode_todo  ; 2b
    equw opcode_todo  ; 2c
    equw opcode_todo  ; 2d
    equw opcode_todo  ; 2e
    equw opcode_todo  ; 2f
    equw opcode_todo  ; 30
    equw opcode_todo  ; 31
    equw opcode_todo  ; 32
    equw opcode_todo  ; 33
    equw opcode_todo  ; 34
    equw opcode_todo  ; 35
    equw opcode_todo  ; 36
    equw opcode_todo  ; 37
    equw opcode_todo  ; 38
    equw opcode_todo  ; 39
    equw opcode_todo  ; 3a
    equw opcode_todo  ; 3b
    equw opcode_todo  ; 3c
    equw opcode_todo  ; 3d
    equw opcode_todo  ; 3e
    equw opcode_todo  ; 3f
    equw opcode_todo  ; 40
    equw opcode_todo  ; 41
    equw opcode_todo  ; 42
    equw opcode_todo  ; 43
    equw opcode_todo  ; 44
    equw opcode_todo  ; 45
    equw opcode_todo  ; 46
    equw opcode_todo  ; 47
    equw opcode_todo  ; 48
    equw opcode_todo  ; 49
    equw opcode_todo  ; 4a
    equw opcode_todo  ; 4b
    equw opcode_todo  ; 4c
    equw opcode_todo  ; 4d
    equw opcode_todo  ; 4e
    equw opcode_todo  ; 4f
    equw opcode_todo  ; 50
    equw opcode_todo  ; 51
    equw opcode_todo  ; 52
    equw opcode_todo  ; 53
    equw opcode_todo  ; 54
    equw opcode_todo  ; 55
    equw opcode_todo  ; 56
    equw opcode_todo  ; 57
    equw opcode_todo  ; 58
    equw opcode_todo  ; 59
    equw opcode_todo  ; 5a
    equw opcode_todo  ; 5b
    equw opcode_todo  ; 5c
    equw opcode_todo  ; 5d
    equw opcode_todo  ; 5e
    equw opcode_todo  ; 5f
    equw opcode_todo  ; 60
    equw opcode_todo  ; 61
    equw opcode_todo  ; 62
    equw opcode_todo  ; 63
    equw opcode_todo  ; 64
    equw opcode_todo  ; 65
    equw opcode_todo  ; 66
    equw opcode_todo  ; 67
    equw opcode_todo  ; 68
    equw opcode_todo  ; 69
    equw opcode_todo  ; 6a
    equw opcode_todo  ; 6b
    equw opcode_todo  ; 6c
    equw opcode_todo  ; 6d
    equw opcode_todo  ; 6e
    equw opcode_todo  ; 6f
    equw opcode_todo  ; 70
    equw opcode_todo  ; 71
    equw opcode_todo  ; 72
    equw opcode_todo  ; 73
    equw opcode_todo  ; 74
    equw opcode_todo  ; 75
    equw opcode_todo  ; 76
    equw opcode_todo  ; 77
    equw opcode_todo  ; 78
    equw opcode_todo  ; 79
    equw opcode_todo  ; 7a
    equw opcode_todo  ; 7b
    equw opcode_todo  ; 7c
    equw opcode_todo  ; 7d
    equw opcode_todo  ; 7e
    equw opcode_todo  ; 7f
.dispatch_table_fd_high
    equw opcode_todo  ; 80
    equw opcode_todo  ; 81
    equw opcode_todo  ; 82
    equw opcode_todo  ; 83
    equw opcode_todo  ; 84
    equw opcode_todo  ; 85
    equw opcode_todo  ; 86
    equw opcode_todo  ; 87
    equw opcode_todo  ; 88
    equw opcode_todo  ; 89
    equw opcode_todo  ; 8a
    equw opcode_todo  ; 8b
    equw opcode_todo  ; 8c
    equw opcode_todo  ; 8d
    equw opcode_todo  ; 8e
    equw opcode_todo  ; 8f
    equw opcode_todo  ; 90
    equw opcode_todo  ; 91
    equw opcode_todo  ; 92
    equw opcode_todo  ; 93
    equw opcode_todo  ; 94
    equw opcode_todo  ; 95
    equw opcode_todo  ; 96
    equw opcode_todo  ; 97
    equw opcode_todo  ; 98
    equw opcode_todo  ; 99
    equw opcode_todo  ; 9a
    equw opcode_todo  ; 9b
    equw opcode_todo  ; 9c
    equw opcode_todo  ; 9d
    equw opcode_todo  ; 9e
    equw opcode_todo  ; 9f
    equw opcode_todo  ; a0
    equw opcode_todo  ; a1
    equw opcode_todo  ; a2
    equw opcode_todo  ; a3
    equw opcode_todo  ; a4
    equw opcode_todo  ; a5
    equw opcode_todo  ; a6
    equw opcode_todo  ; a7
    equw opcode_todo  ; a8
    equw opcode_todo  ; a9
    equw opcode_todo  ; aa
    equw opcode_todo  ; ab
    equw opcode_todo  ; ac
    equw opcode_todo  ; ad
    equw opcode_todo  ; ae
    equw opcode_todo  ; af
    equw opcode_todo  ; b0
    equw opcode_todo  ; b1
    equw opcode_todo  ; b2
    equw opcode_todo  ; b3
    equw opcode_todo  ; b4
    equw opcode_todo  ; b5
    equw opcode_todo  ; b6
    equw opcode_todo  ; b7
    equw opcode_todo  ; b8
    equw opcode_todo  ; b9
    equw opcode_todo  ; ba
    equw opcode_todo  ; bb
    equw opcode_todo  ; bc
    equw opcode_todo  ; bd
    equw opcode_todo  ; be
    equw opcode_todo  ; bf
    equw opcode_todo  ; c0
    equw opcode_todo  ; c1
    equw opcode_todo  ; c2
    equw opcode_todo  ; c3
    equw opcode_todo  ; c4
    equw opcode_todo  ; c5
    equw opcode_todo  ; c6
    equw opcode_todo  ; c7
    equw opcode_todo  ; c8
    equw opcode_todo  ; c9
    equw opcode_todo  ; ca
    equw opcode_todo  ; cb
    equw opcode_todo  ; cc
    equw opcode_todo  ; cd
    equw opcode_todo  ; ce
    equw opcode_todo  ; cf
    equw opcode_todo  ; d0
    equw opcode_todo  ; d1
    equw opcode_todo  ; d2
    equw opcode_todo  ; d3
    equw opcode_todo  ; d4
    equw opcode_todo  ; d5
    equw opcode_todo  ; d6
    equw opcode_todo  ; d7
    equw opcode_todo  ; d8
    equw opcode_todo  ; d9
    equw opcode_todo  ; da
    equw opcode_todo  ; db
    equw opcode_todo  ; dc
    equw opcode_todo  ; dd
    equw opcode_todo  ; de
    equw opcode_todo  ; df
    equw opcode_todo  ; e0
    equw opcode_handler_fd_e1
    equw opcode_todo  ; e2
    equw opcode_todo  ; e3
    equw opcode_todo  ; e4
    equw opcode_handler_fd_e5
    equw opcode_todo  ; e6
    equw opcode_todo  ; e7
    equw opcode_todo  ; e8
    equw opcode_todo  ; e9
    equw opcode_todo  ; ea
    equw opcode_todo  ; eb
    equw opcode_todo  ; ec
    equw opcode_todo  ; ed
    equw opcode_todo  ; ee
    equw opcode_todo  ; ef
    equw opcode_todo  ; f0
    equw opcode_todo  ; f1
    equw opcode_todo  ; f2
    equw opcode_todo  ; f3
    equw opcode_todo  ; f4
    equw opcode_todo  ; f5
    equw opcode_todo  ; f6
    equw opcode_todo  ; f7
    equw opcode_todo  ; f8
    equw opcode_todo  ; f9
    equw opcode_todo  ; fa
    equw opcode_todo  ; fb
    equw opcode_todo  ; fc
    equw opcode_todo  ; fd
    equw opcode_todo  ; fe
    equw opcode_todo  ; ff

    align &100
    include "tables.beebasm"

    align &100
.swr_bank_table
    for i, 0, &ff
        equb 4 + i / &40
    next


.zp_code_copy
    skip zp_code_len
    copyblock zp_code_start, zp_code_end, zp_code_copy

.end

    puttext "boot.txt", "!BOOT", 0
    ; TODO: Starting with a self-built version of the documented instructions test - I may 
    ; well do undocumented instructions eventually but seems best to start with the more
    ; useful ones.
    putfile "zexall/zexdoc-sf.cim", "T.ZEXALL", &8100, &8100
    save "Z80EM", start, end
