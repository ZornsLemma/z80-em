; For now I'm targetting a Master 128 and will use CMOS instructions freely.
    cpu 1

romsel = &fe30
romsel_copy = &f4

osasci = &ffe3

; TODO: I'm putting paging in a macro partly in case there's a way I can disable interrupts most of the time and then get away with not having to update romsel_copy
macro page_in_bank_a
    sta romsel_copy
    sta romsel
endmacro
macro page_in_bank_y
    sty romsel_copy
    sty romsel
endmacro

; TODO: This macro may not be all that useful if we only call it once, but let's go with it for now
macro set_z80_pc_abs abs
    ldx #hi(abs)
    stx z80_pch_logical
    lda swr_bank_table,x
    page_in_bank_a
    lda #(hi(abs) and %00111111) or %10000000
    sta z80_pch_physical
    ldy #lo(abs)
endmacro
    
; The main instruction dispatch loop is executed from zero page.
; The handlers may use A and X as scratch registers but must preserve:
; - Y, the low byte of the Z80 PC
; - the currently paged in RAM bank is the one containing the Z80 PC
    org 0
    guard &90
.zp_code_start
.dispatch_loop
{
    iny
    beq new_pc_page
.new_pc_page_return
.^dispatch_loop_no_increment
.^lda_z80_pc_physical_abs_y
    lda &ff00,y
; TODO: START TEMP HACK TO DETECT EXECUTING AT $0005
    sta zp_tmp
    cpy #5
    bne not_5
    lda z80_pch_logical
    bne not_5
    jmp bdos_emulation
.not_5
    lda zp_tmp
; TODO: END TEMP HACK
    asl a
    tax
    bcs top_bit_set_opcode
    jmp (dispatch_table_low,x)
.top_bit_set_opcode
    jmp (dispatch_table_high,x)

.new_pc_page
    ; TODO: This could potentially be put into a subroutine without too much
    ; performance impact if we're short on zero page space.
    inc z80_pch_logical
    inc z80_pch_physical
    lda z80_pch_physical
    cmp #&c0
    bne new_pc_page_return
    jsr update_z80_pch_physical
    jmp new_pc_page_return
}
.zp_code_end
zp_code_len = zp_code_end - zp_code_start

; Zero page variables
.z80_pch_logical equb 0
z80_pc_physical = lda_z80_pc_physical_abs_y + 1
z80_pch_physical = lda_z80_pc_physical_abs_y + 2
.z80_pc_physical_bank_tmp equb 0 ; normally paged in, just temporary storage
.z80_pcl_tmp equb 0 ; normally in Y, just temporary storage
.z80_a equb 0
.z80_f equb 0
.z80_b equb 0
.z80_c equb 0
.z80_d equb 0
.z80_e equb 0
.z80_h equb 0
.z80_l equb 0
.z80_sp equw 0
.operand_ptr equw 0 ; low byte always 0
.zp_tmp equw 0 ; temporary workspace

; The 6502 N, Z and C flags correspond closely to the Z80 S, Z and C flags,
; although they live at different bit positions in the flags register. To track
; the Z80 flags as efficiently as possible, z80_f holds "hybrid flags" - these
; are the Z80 flags but rearranged to use the 6502 bit positions. These need to
; be converted to use the correct bit positions when exposed to code running on
; the emulated Z80.
;
;        b76543210
; Hybrid: SN H PZC
; Z80:    SZ H PNC
hybrid_flag_s = 1 << 7 ; 6502 N flag
hybrid_flag_z = 1 << 1 ; 6502 Z flag
hybrid_flag_c = 1 << 0 ; 6502 C flag
hybrid_flag_sz = hybrid_flag_s or hybrid_flag_z

    org &e00
    guard &8000
.start
    ; Copy the zero page code into the correct location.
{
    ldy #zp_code_len - 1
.loop
    lda zp_code_copy,y
    sta zp_code_start,y
    dey
    bpl loop
}

    ; Initialise zero page.
    lda #0
    sta operand_ptr

    ; Store top of RAM at address 6. TODO: This is a bit of a hack but it seems
    ; to be what zexall wants to initialise sp; I suspect eventually this will
    ; be populated by the CP/M BDOS or whatever.
    lda #4
    page_in_bank_a
    lda #0
    sta &8006
    lda #&f0
    sta &8007

    ; TODO: This isn't the right start address, but during initial development I
    ; will just have a validation program pre-loaded into memory here.
    set_z80_pc_abs &100

    ; Start executing instructions.
    jmp dispatch_loop_no_increment


; Update z80_pch_physical and page in the correct RAM bank to match z80_pch_logical.
.update_z80_pch_physical
    ldx z80_pch_logical
    lda swr_bank_table,x
    page_in_bank_a
    txa
    and #%00111111
    ora #%10000000
    sta z80_pch_physical
    rts

.update_z80_pch_physical_and_dispatch
; TODO: DUPLICATION OF CODE FOR PREV VERSION, SHARE VIA MACRO
    ldx z80_pch_logical
    lda swr_bank_table,x
    page_in_bank_a
    txa
    and #%00111111
    ora #%10000000
    sta z80_pch_physical
    jmp dispatch_loop_no_increment

    ; TODO: Get rid of this when all opcodes implemented
.opcode_todo
    brk

    ; TODO MOVE MACROS TO TOP
macro advance_pc_and_load
    iny
    ; TODO: Can I avoid having to take the branch in the common case?
    bne not_new_pc_page
    ; TODO: Copy of code in zp dispatch loop, factor out using a macro?
    inc z80_pch_logical
    inc z80_pch_physical
    lda z80_pch_physical
    cmp #&c0
    bne not_new_pc_bank
    jsr update_z80_pch_physical
.not_new_pc_page
.not_new_pc_bank
    lda (z80_pc_physical),y
endmacro

    ; TODO: Copy of code in zp dispatch loop, factor out using a macro?
.new_pc_page_and_dispatch_loop_no_increment
{
    inc z80_pch_logical
    inc z80_pch_physical
    lda z80_pch_physical
    cmp #&c0
    bne not_new_pc_bank
    jsr update_z80_pch_physical
.not_new_pc_bank
    jmp dispatch_loop_no_increment
}

; TODO: DESCRIBE
; TODO: MAKE A MACRO?
.set_operand_ptr_using_a
    tax
    and #%00111111
    ora #%10000000
    sta operand_ptr + 1
    lda swr_bank_table,x
    page_in_bank_a
    rts

; Increment Y and/or operand_ptr so lda (operand_ptr),y accesses the next byte.
; TODO: MAKE A MACRO?
.bump_operand_ptr_y
{
    iny
    beq new_page
    rts
.new_page
    inc operand_ptr + 1
    lda operand_ptr + 1
    cmp #&c0
    beq new_bank
    rts
.new_bank
    lda #&80
    sta operand_ptr + 1
    ; TODO: This is a hack - it relies on the banks being contiguous on Master.
    lda romsel_copy
    inc a
    page_in_bank_a
    rts
}

; TODO: Maybe fold storing/restoring Y into these macros as well? Change name of course.
macro store_pc_bank_and_y
    sty z80_pcl_tmp
    ldy romsel_copy
    sty z80_pc_physical_bank_tmp
endmacro

; This preserves A and X.
macro restore_pc_bank_and_y
    ldy z80_pc_physical_bank_tmp
    page_in_bank_y
    ldy z80_pcl_tmp
endmacro

macro ld_r_8 r
    advance_pc_and_load
    sta r
    jmp dispatch_loop
endmacro

; TODO: MOVE MACRO TO TOP
macro ld_r_s_fragment r, s
    lda s
    sta r
endmacro

macro ld_r_s r, s
    ld_r_s_fragment r, s
    jmp dispatch_loop
endmacro

macro ld_rr_16 high_r, low_r
    advance_pc_and_load
    sta low_r
    advance_pc_and_load
    sta high_r
    jmp dispatch_loop
endmacro

macro ind_hl
    store_pc_bank_and_y
    lda z80_h
    jsr set_operand_ptr_using_a
    ldy z80_l
    lda (operand_ptr),y
    restore_pc_bank_and_y
endmacro

macro ld_r_ind_hl r
    ind_hl
    sta r
    jmp dispatch_loop
endmacro

macro inc_rr high_r, low_r
    inc low_r
    bne no_carry
    inc high_r
.no_carry
    jmp dispatch_loop
endmacro

macro dec_rr high_r, low_r
    lda low_r
    bne no_borrow
    dec high_r
.no_borrow
    dec low_r
    jmp dispatch_loop
endmacro

macro or_6502_a
    ora z80_a
    sta z80_a
    tax
    ; Clear H, N, C and set S, Z, P according to result
    php
    pla
    and #hybrid_flag_sz
    ora parity_table,x
    sta z80_f
    jmp dispatch_loop
endmacro

macro jp
    advance_pc_and_load
    sta z80_pcl_tmp
    advance_pc_and_load
    sta z80_pch_logical
    ldy z80_pcl_tmp
    jmp update_z80_pch_physical_and_dispatch
endmacro

macro jp_flag_set hybrid_flag
    ; TODO: We could probably write some if-else macro code to optimise detection of bits which we can test with the "bit" instruction rather than needing to do lda-then-and
    lda z80_f
    and #hybrid_flag
    beq no_branch
    jp
.no_branch
    tya
    clc
    adc #3
    tay
    bcs carry
    jmp dispatch_loop_no_increment
.carry
    jmp new_pc_page_and_dispatch_loop_no_increment
endmacro

macro push_internal high, low, save_pc_bank_and_y
if save_pc_bank_and_y
    store_pc_bank_and_y
endif
    sec
    lda z80_sp
    sbc #2
    sta z80_sp
    tay
    bcs no_borrow
    dec z80_sp + 1
.no_borrow
    lda z80_sp + 1
    jsr set_operand_ptr_using_a
    ; TODO: Which order do the bytes get pushed onto the stack? This order seems logical but may not be correct.
    lda low
    sta (operand_ptr),y
    jsr bump_operand_ptr_y
    lda high
    sta (operand_ptr),y
if save_pc_bank_and_y
    restore_pc_bank_and_y
endif
endmacro

macro push_corrupt_pc_bank_and_y high, low
    push_internal high, low, FALSE
endmacro

macro push high, low
    push_internal high, low, TRUE
endmacro

macro pop_internal high, low, save_pc_bank_and_y
if save_pc_bank_and_y
    store_pc_bank_and_y
endif
    lda z80_sp + 1
    jsr set_operand_ptr_using_a
    ldy z80_sp
    ; TODO: Which order do the bytes get popped off the stack? This order seems logical but may not be correct.
    lda (operand_ptr),y
    sta low
    jsr bump_operand_ptr_y
    lda (operand_ptr),y
    sta high
    clc
    lda z80_sp
    adc #2
    sta z80_sp
    bcc no_carry
    inc z80_sp + 1
.no_carry
if save_pc_bank_and_y
    restore_pc_bank_and_y
endif
endmacro

macro pop_corrupt_pc_bank_and_y high, low
    pop_internal high, low, FALSE
endmacro

macro pop high, low
    pop_internal high, low, TRUE
endmacro

; Instruction: ld bc,**
.opcode_handler_01
    ld_rr_16 z80_b, z80_c

; Instruction: inc bc
.opcode_handler_03
    inc_rr z80_b, z80_c

; Instruction: dec bc
.opcode_handler_0b
    dec_rr z80_b, z80_c

; Instruction: ld c,*
.opcode_handler_0e
    ld_r_8 z80_c

; Instruction: ld de,**
.opcode_handler_11
    ld_rr_16 z80_d, z80_e

; Instruction: inc de
.opcode_handler_13
    inc_rr z80_d, z80_e

; Instruction: dec de
.opcode_handler_1b
    dec_rr z80_d, z80_e

; Instruction: ld hl,**
.opcode_handler_21
    ld_rr_16 z80_h, z80_l

; Instruction: inc hl
.opcode_handler_23
    inc_rr z80_h, z80_l

; Instruction: ld hl,(**)
.opcode_handler_2a
    advance_pc_and_load
    sta zp_tmp
    advance_pc_and_load
    store_pc_bank_and_y
    jsr set_operand_ptr_using_a
    ldy zp_tmp
    lda (operand_ptr),y
    sta z80_l
    jsr bump_operand_ptr_y
    lda (operand_ptr),y
    sta z80_h
    restore_pc_bank_and_y
    jmp dispatch_loop

; Instruction: dec hl
.opcode_handler_2b
    dec_rr z80_h, z80_l

; Instruction: ld sp,**
.opcode_handler_31
    ld_rr_16 z80_sp + 1, z80_sp

; Instruction: inc sp
.opcode_handler_33
    inc_rr z80_sp + 1, z80_sp

; Instruction: dec sp
.opcode_handler_3b
    dec_rr z80_sp + 1, z80_sp

; Instruction: ld b,(hl)
.opcode_handler_46
    ld_r_ind_hl z80_b

; Instruction: ld c,(hl)
.opcode_handler_4e
    ld_r_ind_hl z80_c

; Instruction: ld c,a
.opcode_handler_4f
    ld_r_s z80_c, z80_a

; Instruction: ld d,(hl)
.opcode_handler_56
    ld_r_ind_hl z80_d

; Instruction: ld e,(hl)
.opcode_handler_5e
    ld_r_ind_hl z80_e

; Instruction: ld e,a
.opcode_handler_5f
    ld_r_s z80_e, z80_a

; Instruction: ld h,(hl)
.opcode_handler_66
    ld_r_ind_hl z80_h

; Instruction: ld l,(hl)
.opcode_handler_6e
    ld_r_ind_hl z80_l

; Instruction: ld l,a
.opcode_handler_6f
    ld_r_s z80_l, z80_a

; Instruction: ld a,(hl)
.opcode_handler_7e
    ld_r_ind_hl z80_a

; Instruction: ld a,a
.opcode_handler_7f
    jmp dispatch_loop

; Instruction: or (hl)
.opcode_handler_b6
    ind_hl
    or_6502_a

; Instruction: pop bc
.opcode_handler_c1
    pop z80_b, z80_c
    jmp dispatch_loop

; Instruction: jp **
.opcode_handler_c3
    jp


    

; Instruction: push bc
.opcode_handler_c5
    push z80_b, z80_c
    jmp dispatch_loop

; Instruction: ret
.opcode_handler_c9
    pop_corrupt_pc_bank_and_y z80_pch_logical, z80_pcl_tmp
    ldy z80_pcl_tmp
    jmp update_z80_pch_physical_and_dispatch

; Instruction: jp z,**
.opcode_handler_ca
    jp_flag_set hybrid_flag_z

; Instruction: call **
.opcode_handler_cd
{
    advance_pc_and_load
    sta z80_pcl_tmp
    advance_pc_and_load
    sta zp_tmp
    ; Push the address of the next instruction onto the stack.
    iny
    bne no_carry
    inc z80_pch_logical
.no_carry
    sty zp_tmp + 1
    push_corrupt_pc_bank_and_y z80_pch_logical, zp_tmp + 1
    lda zp_tmp
    sta z80_pch_logical
    ldy z80_pcl_tmp
    jmp update_z80_pch_physical_and_dispatch
}

; Instruction: pop de
.opcode_handler_d1
    pop z80_d, z80_e
    jmp dispatch_loop

; Instruction: push de
.opcode_handler_d5
    push z80_d, z80_e
    jmp dispatch_loop

; Instruction: pop hl
.opcode_handler_e1
    pop z80_h, z80_l
    jmp dispatch_loop

; Instruction: push hl
.opcode_handler_e5
    push z80_h, z80_l
    jmp dispatch_loop

; Instruction: pop af
.opcode_handler_f1
    pop z80_a, zp_tmp
    ldx zp_tmp
    lda flag_permutation_table,x
    sta z80_f
    jmp dispatch_loop

; Instruction: push af
.opcode_handler_f5
    ldx z80_f
    lda flag_permutation_table,x
    sta zp_tmp
    push z80_a, zp_tmp
    jmp dispatch_loop

; Instruction: ld sp,hl
.opcode_handler_f9
    ld_r_s_fragment z80_sp  ,z80_l
    ld_r_s          z80_sp+1,z80_h
    jmp dispatch_loop


; TODO: Temporary hack to emulate bdos functions necessary for test code
.bdos_emulation
    lda z80_c
    cmp #9
    beq bdos_emulation_writestr
    brk
.bdos_emulation_writestr
{
    lda z80_d
    jsr set_operand_ptr_using_a
    ldy z80_e
.loop
    lda (operand_ptr),y
    cmp #'$'
    beq done
    jsr osasci
    jsr bump_operand_ptr_y
    jmp loop
.done
    jmp opcode_handler_c9
}


    align &100
.dispatch_table_low
    equw opcode_todo ; &00
    equw opcode_handler_01
    equw opcode_todo ; &02
    equw opcode_handler_03
    equw opcode_todo ; &04
    equw opcode_todo ; &05
    equw opcode_todo ; &06
    equw opcode_todo ; &07
    equw opcode_todo ; &08
    equw opcode_todo ; &09
    equw opcode_todo ; &0a
    equw opcode_handler_0b
    equw opcode_todo ; &0c
    equw opcode_todo ; &0d
    equw opcode_handler_0e
    equw opcode_todo ; &0f
    equw opcode_todo ; &10
    equw opcode_handler_11
    equw opcode_todo ; &12
    equw opcode_handler_13
    equw opcode_todo ; &14
    equw opcode_todo ; &15
    equw opcode_todo ; &16
    equw opcode_todo ; &17
    equw opcode_todo ; &18
    equw opcode_todo ; &19
    equw opcode_todo ; &1a
    equw opcode_handler_1b
    equw opcode_todo ; &1c
    equw opcode_todo ; &1d
    equw opcode_todo ; &1e
    equw opcode_todo ; &1f
    equw opcode_todo ; &20
    equw opcode_handler_21
    equw opcode_todo ; &22
    equw opcode_handler_23
    equw opcode_todo ; &24
    equw opcode_todo ; &25
    equw opcode_todo ; &26
    equw opcode_todo ; &27
    equw opcode_todo ; &28
    equw opcode_todo ; &29
    equw opcode_handler_2a
    equw opcode_handler_2b
    equw opcode_todo ; &2c
    equw opcode_todo ; &2d
    equw opcode_todo ; &2e
    equw opcode_todo ; &2f
    equw opcode_todo ; &30
    equw opcode_handler_31
    equw opcode_todo ; &32
    equw opcode_handler_33
    equw opcode_todo ; &34
    equw opcode_todo ; &35
    equw opcode_todo ; &36
    equw opcode_todo ; &37
    equw opcode_todo ; &38
    equw opcode_todo ; &39
    equw opcode_todo ; &3a
    equw opcode_handler_3b
    equw opcode_todo ; &3c
    equw opcode_todo ; &3d
    equw opcode_todo ; &3e
    equw opcode_todo ; &3f
    equw opcode_todo ; &40
    equw opcode_todo ; &41
    equw opcode_todo ; &42
    equw opcode_todo ; &43
    equw opcode_todo ; &44
    equw opcode_todo ; &45
    equw opcode_handler_46
    equw opcode_todo ; &47
    equw opcode_todo ; &48
    equw opcode_todo ; &49
    equw opcode_todo ; &4a
    equw opcode_todo ; &4b
    equw opcode_todo ; &4c
    equw opcode_todo ; &4d
    equw opcode_handler_4e
    equw opcode_handler_4f
    equw opcode_todo ; &50
    equw opcode_todo ; &51
    equw opcode_todo ; &52
    equw opcode_todo ; &53
    equw opcode_todo ; &54
    equw opcode_todo ; &55
    equw opcode_handler_56
    equw opcode_todo ; &57
    equw opcode_todo ; &58
    equw opcode_todo ; &59
    equw opcode_todo ; &5a
    equw opcode_todo ; &5b
    equw opcode_todo ; &5c
    equw opcode_todo ; &5d
    equw opcode_handler_5e
    equw opcode_handler_5f
    equw opcode_todo ; &60
    equw opcode_todo ; &61
    equw opcode_todo ; &62
    equw opcode_todo ; &63
    equw opcode_todo ; &64
    equw opcode_todo ; &65
    equw opcode_handler_66
    equw opcode_todo ; &67
    equw opcode_todo ; &68
    equw opcode_todo ; &69
    equw opcode_todo ; &6a
    equw opcode_todo ; &6b
    equw opcode_todo ; &6c
    equw opcode_todo ; &6d
    equw opcode_handler_6e
    equw opcode_handler_6f
    equw opcode_todo ; &70
    equw opcode_todo ; &71
    equw opcode_todo ; &72
    equw opcode_todo ; &73
    equw opcode_todo ; &74
    equw opcode_todo ; &75
    equw opcode_todo ; &76
    equw opcode_todo ; &77
    equw opcode_todo ; &78
    equw opcode_todo ; &79
    equw opcode_todo ; &7a
    equw opcode_todo ; &7b
    equw opcode_todo ; &7c
    equw opcode_todo ; &7d
    equw opcode_handler_7e
    equw opcode_handler_7f
.dispatch_table_high
    equw opcode_todo ; &80
    equw opcode_todo ; &81
    equw opcode_todo ; &82
    equw opcode_todo ; &83
    equw opcode_todo ; &84
    equw opcode_todo ; &85
    equw opcode_todo ; &86
    equw opcode_todo ; &87
    equw opcode_todo ; &88
    equw opcode_todo ; &89
    equw opcode_todo ; &8a
    equw opcode_todo ; &8b
    equw opcode_todo ; &8c
    equw opcode_todo ; &8d
    equw opcode_todo ; &8e
    equw opcode_todo ; &8f
    equw opcode_todo ; &90
    equw opcode_todo ; &91
    equw opcode_todo ; &92
    equw opcode_todo ; &93
    equw opcode_todo ; &94
    equw opcode_todo ; &95
    equw opcode_todo ; &96
    equw opcode_todo ; &97
    equw opcode_todo ; &98
    equw opcode_todo ; &99
    equw opcode_todo ; &9a
    equw opcode_todo ; &9b
    equw opcode_todo ; &9c
    equw opcode_todo ; &9d
    equw opcode_todo ; &9e
    equw opcode_todo ; &9f
    equw opcode_todo ; &a0
    equw opcode_todo ; &a1
    equw opcode_todo ; &a2
    equw opcode_todo ; &a3
    equw opcode_todo ; &a4
    equw opcode_todo ; &a5
    equw opcode_todo ; &a6
    equw opcode_todo ; &a7
    equw opcode_todo ; &a8
    equw opcode_todo ; &a9
    equw opcode_todo ; &aa
    equw opcode_todo ; &ab
    equw opcode_todo ; &ac
    equw opcode_todo ; &ad
    equw opcode_todo ; &ae
    equw opcode_todo ; &af
    equw opcode_todo ; &b0
    equw opcode_todo ; &b1
    equw opcode_todo ; &b2
    equw opcode_todo ; &b3
    equw opcode_todo ; &b4
    equw opcode_todo ; &b5
    equw opcode_handler_b6
    equw opcode_todo ; &b7
    equw opcode_todo ; &b8
    equw opcode_todo ; &b9
    equw opcode_todo ; &ba
    equw opcode_todo ; &bb
    equw opcode_todo ; &bc
    equw opcode_todo ; &bd
    equw opcode_todo ; &be
    equw opcode_todo ; &bf
    equw opcode_todo ; &c0
    equw opcode_handler_c1
    equw opcode_todo ; &c2
    equw opcode_handler_c3
    equw opcode_todo ; &c4
    equw opcode_handler_c5
    equw opcode_todo ; &c6
    equw opcode_todo ; &c7
    equw opcode_todo ; &c8
    equw opcode_handler_c9
    equw opcode_handler_ca
    equw opcode_todo ; &cb
    equw opcode_todo ; &cc
    equw opcode_handler_cd
    equw opcode_todo ; &ce
    equw opcode_todo ; &cf
    equw opcode_todo ; &d0
    equw opcode_handler_d1
    equw opcode_todo ; &d2
    equw opcode_todo ; &d3
    equw opcode_todo ; &d4
    equw opcode_handler_d5
    equw opcode_todo ; &d6
    equw opcode_todo ; &d7
    equw opcode_todo ; &d8
    equw opcode_todo ; &d9
    equw opcode_todo ; &da
    equw opcode_todo ; &db
    equw opcode_todo ; &dc
    equw opcode_todo ; &dd
    equw opcode_todo ; &de
    equw opcode_todo ; &df
    equw opcode_todo ; &e0
    equw opcode_handler_e1
    equw opcode_todo ; &e2
    equw opcode_todo ; &e3
    equw opcode_todo ; &e4
    equw opcode_handler_e5
    equw opcode_todo ; &e6
    equw opcode_todo ; &e7
    equw opcode_todo ; &e8
    equw opcode_todo ; &e9
    equw opcode_todo ; &ea
    equw opcode_todo ; &eb
    equw opcode_todo ; &ec
    equw opcode_todo ; &ed
    equw opcode_todo ; &ee
    equw opcode_todo ; &ef
    equw opcode_todo ; &f0
    equw opcode_handler_f1
    equw opcode_todo ; &f2
    equw opcode_todo ; &f3
    equw opcode_todo ; &f4
    equw opcode_handler_f5
    equw opcode_todo ; &f6
    equw opcode_todo ; &f7
    equw opcode_todo ; &f8
    equw opcode_handler_f9
    equw opcode_todo ; &fa
    equw opcode_todo ; &fb
    equw opcode_todo ; &fc
    equw opcode_todo ; &fd
    equw opcode_todo ; &fe
    equw opcode_todo ; &ff

    align &100
    include "tables.beebasm"

    align &100
.swr_bank_table
    for i, 0, &ff
        equb 4 + i / &40
    next


.zp_code_copy
    skip zp_code_len
    copyblock zp_code_start, zp_code_end, zp_code_copy

.end

    puttext "boot.txt", "!BOOT", 0
    ; TODO: Starting with a self-built version of the documented instructions test - I may 
    ; well do undocumented instructions eventually but seems best to start with the more
    ; useful ones.
    putfile "zexall/zexdoc-sf.cim", "T.ZEXALL", &8100, &8100
    save "Z80EM", start, end
